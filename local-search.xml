<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Clean-Code-筆記-2</title>
    <link href="/2024/12/29/Clean-Code-%E7%AD%86%E8%A8%98-2/"/>
    <url>/2024/12/29/Clean-Code-%E7%AD%86%E8%A8%98-2/</url>
    
    <content type="html"><![CDATA[<p>本次是繼續上回的Clean Code筆記，廢話不多說，Let’s us begin.</p><h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><hr><h4 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h4><ol><li>撰寫一個單元測試前不應該撰寫產品程式碼</li><li>只撰寫剛好能通過的產品程式碼</li><li>只撰寫剛好能通過當前測試失敗的產品程式碼</li></ol><ul><li>撰寫測試的好處可以讓你更動程式碼時不那麼恐懼， 需要注意的是，測試程式碼同樣需要與時俱進，若沒有跟著調整容易造成程式碼的腐敗，最終測試程式碼的品質同樣影響產品程式碼。</li><li>測試程式碼要求的是可讀性 闡明性(Clarity)，而不是效能。</li><li>盡量維持一個測試一個斷言(Assert)，讓一個測試只會顯示一個結果，方便開發者評估功能。(一個測試只測試一個概念)</li></ul><h4 id="TDD-FIRST原則"><a href="#TDD-FIRST原則" class="headerlink" title="TDD FIRST原則"></a>TDD FIRST原則</h4><ul><li>Fast 測試應該要夠快</li><li>Independent 測試應該要能夠獨立運行，不依賴其他測試程式</li><li>Repeatable 測試應該要能夠重複使用</li><li>Self-Validating 測試應該要能夠自我驗證，顯示要測試的概念是否成功運作</li><li>Timely 要在產品程式之前被撰寫，若是之後才撰寫，經常會發現撰寫出來的產品程式碼並不好被測試</li></ul><h3 id="Class-Level"><a href="#Class-Level" class="headerlink" title="Class-Level"></a>Class-Level</h3><h4 id="單一職責原則-Single-Responsibility-Principle-SRP"><a href="#單一職責原則-Single-Responsibility-Principle-SRP" class="headerlink" title="單一職責原則(Single Responsibility Principle, SRP)"></a>單一職責原則(Single Responsibility Principle, SRP)</h4><p>單一職責原則主張，一個類別或一個模組應該只能有一個，而且只能有一個被修改的理由。<br>個人對這段的理解是，一個類別的職責應該是很明確的，他只該負責一件事，而需要修改類別的原因，<br>必須得是當初認為要做的那件事。 比方說有一個專門處理報表Excel輸出的類別ExcelObject，若今天需要做輸出Excel之外的事<br>，比方說：判斷格式、字串拼接、欄位驗證、給定預設值，若因為這些理由而修改了ExcelObject，就是違反了SRP。</p><h5 id="凝聚力"><a href="#凝聚力" class="headerlink" title="凝聚力"></a>凝聚力</h5><p>類別中的方法，盡量讓每個變數都被使用在每一個方法中。<br>當類別失去凝聚力時，就應該將它拆開</p><h4 id="開放閉合原則-Open-Closed-Principle"><a href="#開放閉合原則-Open-Closed-Principle" class="headerlink" title="開放閉合原則(Open-Closed Principle)"></a>開放閉合原則(Open-Closed Principle)</h4><p>類別應該要對擴充具備開放性，但對修改具有閉合性。</p><h4 id="隔離修改"><a href="#隔離修改" class="headerlink" title="隔離修改"></a>隔離修改</h4><p>…待續</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Clean Code</tag>
      
      <tag>Java</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Remark Page</title>
    <link href="/2024/12/28/hello-world/"/>
    <url>/2024/12/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Hexo 模板 資訊參考：<a href="https://hexo.fluid-dev.com/docs/guide/#%E9%85%8D%E7%BD%AE">https://hexo.fluid-dev.com/docs/guide/#%E9%85%8D%E7%BD%AE</a><br>如何更換Hexo主題 參考文件：<a href="https://s81679.github.io/2020/02/09/change-themes/">https://s81679.github.io/2020/02/09/change-themes/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>memo</tag>
      
      <tag>usage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clean Code 筆記(1)</title>
    <link href="/2024/12/26/Clean-Code-%E7%AD%86%E8%A8%98-1/"/>
    <url>/2024/12/26/Clean-Code-%E7%AD%86%E8%A8%98-1/</url>
    
    <content type="html"><![CDATA[<p>Clean Code的原則包含了多種面向，透過Clean Code的學習，可以使你全方位的檢視自己撰寫與他人撰寫的程式碼是否足夠整潔。<br>以下為自己整理的Clean Code學習筆記：</p><h3 id="變數"><a href="#變數" class="headerlink" title="變數"></a>變數</h3><p>好的變數命名應該要能夠名副其實，比方說：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> day;<br></code></pre></td></tr></table></figure><p>永遠比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> expireDate;<br></code></pre></td></tr></table></figure><p>要來得糟。</p><hr><ul><li>避免使用 <em>O</em> <em>0</em> <em>I</em> <em>L</em> 這些容易誤導、寫錯的字元</li><li>使用能唸出來的名稱，<em>團隊溝通會使用到</em></li><li>使用可被搜尋到的名字 <em>除錯時會使用到</em></li><li>介面與繼承，可使用 Student、StudentImpl作為命名</li><li>命名應該直觀，符合開發人員的想像</li><li>類別應以名詞命名、方法應以動詞命名</li></ul><hr><h3 id="函式"><a href="#函式" class="headerlink" title="函式"></a>函式</h3><p>設計原則</p><ul><li>讓函式只做一件事，SRP。</li><li>參數的數量越少越好，方便開發者了解參數對整理輸出的影響</li><li>不要帶boolean進function，違背了SRP。</li><li>如果要傳入多個參數，用物件包裝會更好，至少符合相同概念。</li><li>輸入與指令分離，ex:判斷條件與操作物件是兩個不同層級的概念，不要放在一起</li><li>不要有副作用，避免不可預料的BUG發生</li><li>以try catch 取代if 判斷，減少巢狀迴圈。</li></ul><hr><h3 id="物件與資料結構"><a href="#物件與資料結構" class="headerlink" title="物件與資料結構"></a>物件與資料結構</h3><ol><li><p>抽象化設計界面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">FuelTankCapacityInGallons();<br><span class="hljs-type">double</span> <span class="hljs-title function_">getGallonsOfGasoline</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">getPercentFuelRemaining</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>採用後者的設計方式可以隱藏資料的細節。</p></li><li><p>資料結構的程式碼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NPC</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">talk</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-keyword">if</span> (object <span class="hljs-keyword">instanceof</span> Merchant) &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (object <span class="hljs-keyword">instanceof</span> Smith) &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>在NPC類別中，要擴充一個新的類別很麻煩，必須要更動所有原先相關的程式碼，以符合函式的架構</li><li>在NPC類別中，新增新的方法很容易，不需更動既有程式碼</li><li></li></ul><ol start="2"><li>物件導向的程式碼<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Merchant</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NPC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">talk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Smith</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NPC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">talk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NPC</span> &#123;<br>    talk();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>在NPC類別中，要寫一個新的類別很容易，不需更動既有程式碼</li><li>在NPC類別中，新增新的方法很麻煩，必須要更動每一個繼承NPC的類別</li></ul><h3 id="例外處理"><a href="#例外處理" class="headerlink" title="例外處理"></a>例外處理</h3><ul><li>視情況，選擇封裝Exception</li><li>不要傳遞Null</li></ul><p>節錄<Clean Code> Ch1~Ch8</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Clean Code</tag>
      
      <tag>Java</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常用指令與說明</title>
    <link href="/2024/12/24/Git-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%88%87%E8%AA%AA%E6%98%8E/"/>
    <url>/2024/12/24/Git-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%88%87%E8%AA%AA%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>我們常用的指令有很多，對資訊科技的學生來說，Git的使用已經是基礎了，更何況是一名資訊工作者。本次是要整理那些常用的指令，以及針對一些細節去做釐清學習。<br>常用的指令整理如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init #初始化Git Repo<br>git status #查看 Git 目錄更動狀態<br>git log # 查看commit紀錄<br>git add  # 將tracked的資料，添加到add區域<br>git commit # 將add區域的資料，提交一筆紀錄<br>git push # 把本地的commit提交至遠端伺服器<br>git reset -soft # 用來拆commit用的 會把HEAD重製到指定位置<br>git reset -mixed # 用來拆commit用的 除了把HEAD重製到指定位置，還會把資料變成untracked狀態<br>git reset -hard # 最少用，重製到指定位置，並刪除之前位置到重製點之前的commit，危險!<br>git checkout: 用來切換分支或恢復檔案，切換到分支時，使HEAD 指向該分支。<br>git merge: 將另一個分支的更改合併到當前分支中，會產生合併提交。<br>git rebase: 用來將一個分支的提交移到另一個分支上，通常用來保持提交歷史簡潔，可以取代 git merge 的方式。<br>git branch: 列出、創建或刪除分支。<br></code></pre></td></tr></table></figure><h4 id="Detach-HEAD-表示當前不在任何分支上，HEAD-直接指向某個提交，通常需要使用-git-checkout-返回分支。"><a href="#Detach-HEAD-表示當前不在任何分支上，HEAD-直接指向某個提交，通常需要使用-git-checkout-返回分支。" class="headerlink" title="Detach HEAD: 表示當前不在任何分支上，HEAD 直接指向某個提交，通常需要使用 git checkout 返回分支。"></a>Detach HEAD: 表示當前不在任何分支上，HEAD 直接指向某個提交，通常需要使用 git checkout 返回分支。</h4><h4 id="Fast-forward-當目標分支可以直接向前推進而不需要合併提交，會自動進行快進合併，保留簡潔的歷史。"><a href="#Fast-forward-當目標分支可以直接向前推進而不需要合併提交，會自動進行快進合併，保留簡潔的歷史。" class="headerlink" title="Fast-forward: 當目標分支可以直接向前推進而不需要合併提交，會自動進行快進合併，保留簡潔的歷史。"></a>Fast-forward: 當目標分支可以直接向前推進而不需要合併提交，會自動進行快進合併，保留簡潔的歷史。</h4><p>大致整理到這邊，後來其實我越來越少用了，主要是IDE內建Git功能很多都比Git Bash shell 的更易於使用了，也有更便捷的一些做法，所以以上僅作個人紀錄之用。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什麼樣的程式碼需要被重構？</title>
    <link href="/2024/12/23/%E4%BB%80%E9%BA%BC%E6%A8%A3%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%9C%80%E8%A6%81%E8%A2%AB%E9%87%8D%E6%A7%8B%EF%BC%9F/"/>
    <url>/2024/12/23/%E4%BB%80%E9%BA%BC%E6%A8%A3%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%9C%80%E8%A6%81%E8%A2%AB%E9%87%8D%E6%A7%8B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>什麼樣的程式碼需要被重構？</p><p>還記得當我在找第一份後端工作時，曾經有被面試官問到有沒有過重構的經驗？當時的我菜得一批，連重構是什麼都講不出來，最後只吞吞吐吐地說自己沒有重構的經驗。後來，受到教訓的我讓自己慢慢去了解重構之後，才慢慢發現「重構」並不是什麼高大上的名詞，有時甚至你還沒聽過這個名詞時，就已經在重構之中了。<br>重構──意指在不影響程式碼功能的情況下，進行程式碼的效能、可讀性、可維護性等等進行調整的行為。小到修正命名不良的變數名稱，大到套用設計模式，調整系統的架構 ( 但前提是功能不受影響 )，這些都可以算是重構。<br>重構──那些變數、方法等級的重構，其實都不算太難。通常會讓人困惑的點更多是在於，我不確定這段程式碼需不需要被重構。假設有一段關於交易的程式碼，中間有超過100行的驗證程式碼，你可能直覺性地覺得應該要提取出來作為一個獨立的方法。但團隊的其他人也許早就習慣了這樣寫，這樣一來，是否真的能夠幫助到其他人理解這段程式碼？<br>這說明了其實很多標準最終你依然得Align自己的開發團隊，而非盲目遵從某些標準或規範。當然能夠判斷出哪部分的程式碼暴露了不必要的細節這點，也需要一些經驗。<br>對於這種模糊不清的感覺，有些人可以無師自通，抓出合理的平衡點。如果不是，我會推薦看Kent Beck的《測試驅動開發》，裡面詳細地描述了如何從一個肥胖的程式碼不斷調整，透過大量的測試，一步步將物件的依賴分離與凝聚力的提升。雖然TDD的開發流程是否適合開發團隊使用是個好問題。但做為學習重構程式碼的第一站來說，我還是認為說《測試驅動開發》會很適合初出茅廬的工程師。<br>此外，對於重構程式碼這件事，TDD還提到一個我認為最重要的觀念。「首先必須要有完善、覆蓋率高的測試程式碼，不然就只是在重寫而已」</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Refactor</tag>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Github Page + Hexo + Vercel 建立你的部落格</title>
    <link href="/2024/12/22/%E7%94%A8Github-Page-Hexo-Vercel-%E5%BB%BA%E7%AB%8B%E4%BD%A0%E7%9A%84%E9%83%A8%E8%90%BD%E6%A0%BC/"/>
    <url>/2024/12/22/%E7%94%A8Github-Page-Hexo-Vercel-%E5%BB%BA%E7%AB%8B%E4%BD%A0%E7%9A%84%E9%83%A8%E8%90%BD%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<p>作為一名開發者，Github已經是每天都無法脫離的工具，除此之外，Github Page也是許多新手工程師的好朋友，使用簡單的指令就可以讓新手工程師建立一個屬於自己的部落格，以下就是簡單介紹要怎麼搭建一個自己的Github Blog<br>我們主要使用Hexo作為框架，他主要以Node.js作為編譯工具。</p><h3 id="環境安裝"><a href="#環境安裝" class="headerlink" title="環境安裝"></a>環境安裝</h3><ol><li>Git(<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>) 版本控制工具</li><li>Node.js(<a href="https://nodejs.org/zh-tw">https://nodejs.org/zh-tw</a>) 執行Hexo框架必備Node.js的套件管理工具。</li></ol><p>安裝完後，打開CMD，輸入 “node -v” 與 “git -v” 看看兩者是不是都有安裝成功，有的話就繼續下去。</p><h1 id="步驟解說"><a href="#步驟解說" class="headerlink" title="步驟解說"></a>步驟解說</h1><h4 id="本機設定"><a href="#本機設定" class="headerlink" title="本機設定"></a>本機設定</h4><ol><li>建立你的工作資料夾。</li><li>在你建立的工作資料夾目錄下，點選右鍵 “Open Git Bash”，開啟Git cmd</li><li>安裝Hexo 輸入”npm install -g hexo-cli” npm 是 node.js的套件管理工具，-g 代表在資料夾外也可以使用(global)，hexo-cli是我們要安裝的node.js套件</li><li>安裝完後輸入”hexo -v” 確認hexo 是否有成功安裝，成功的話繼續。</li><li>在你的工作目錄下初始化hexo資訊 CMD輸入”hexo init” 與 “npm install”</li><li>安裝完後輸入 “hexo s” 啟用hexo運作的伺服器範例</li><li>你應該會看到訊息 “Hexo is running at port 4000”，這時可以開啟URL確認看看。</li></ol><p>這樣一來基本的安裝就完成了！</p><h4 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h4><ol><li>註冊Github</li><li>以”你的名字.github.io”建立Repository。</li></ol><h4 id="部署至GithubPage"><a href="#部署至GithubPage" class="headerlink" title="部署至GithubPage"></a>部署至GithubPage</h4><ol><li>在Hexo工作資料夾下安裝套件 “npm install hexo-deployer-git –save”</li><li>打開_config.yml文件，修改以下設定<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol">repository:</span> &lt;你的GithubPage路徑&gt;<br><span class="hljs-symbol">branch:</span> &lt;你要推的分支&gt;<br></code></pre></td></tr></table></figure>修改完後，我們要重新打包，在cmd 輸入 “hexo g” 產生靜態文件。<br>接著輸入 “hexo d”，把你的Hexo Page推到Github上。<br>接著打開你的Repository，並觀察Actions中，是否WorkFlow成功執行完。如果正常結束，那恭喜你，你已經完成了。</li></ol><p>感謝觀看，有任何問題歡迎下方留言，就這樣掰掰。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GithubPage</tag>
      
      <tag>Hexo</tag>
      
      <tag>Vercel</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
